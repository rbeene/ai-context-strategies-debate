<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Messy Codebase Playbook: AI Context That Actually Works</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap');
  body { font-family: 'Inter', sans-serif; }
  code, pre { font-family: 'JetBrains Mono', monospace; }
  html { scroll-behavior: smooth; }
  .sticky-nav { backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); }
</style>
</head>
<body class="bg-stone-50 text-stone-800">

<!-- Navigation -->
<nav class="sticky-nav fixed top-0 w-full bg-stone-50/90 border-b border-stone-200 z-50">
  <div class="max-w-3xl mx-auto px-4 py-3 flex items-center justify-between">
    <a href="index.html" class="text-stone-400 text-xs hover:text-stone-600">&larr; The Context Wars</a>
    <div class="flex gap-6 text-xs font-medium text-stone-500">
      <a href="#today" class="text-red-600 font-semibold hover:text-red-800">Start Here</a>
      <a href="#assess" class="hover:text-stone-800">Assess</a>
      <a href="#rag" class="hover:text-stone-800">RAG</a>
      <a href="#playbook" class="hover:text-stone-800">Playbook</a>
      <a href="#anti-patterns" class="hover:text-stone-800">Anti-Patterns</a>
    </div>
  </div>
</nav>

<!-- Hero -->
<header class="pt-24 pb-12 px-4">
  <div class="max-w-3xl mx-auto">
    <p class="text-red-600 font-semibold text-sm mb-4 tracking-wide uppercase">Practical Guide &middot; February 2026</p>
    <h1 class="text-3xl md:text-4xl font-black leading-tight tracking-tight mb-6">
      Your Codebase Is a Mess.<br>
      <span class="text-stone-500">Here's How to Use AI Anyway.</span>
    </h1>
    <p class="text-base text-stone-600 leading-relaxed max-w-2xl">
      The academic advice assumes you're either starting fresh or working in a clean codebase. You're not. You have inconsistent patterns, missing tests, tribal knowledge that left with the last two developers, and a deadline. This is the playbook for that situation.
    </p>
  </div>
</header>

<!-- The Reality -->
<section class="py-10 px-4 border-t border-stone-200">
  <div class="max-w-3xl mx-auto">
    <h2 class="text-xl font-bold mb-6">Stop. Read This First.</h2>

    <div class="space-y-4 text-sm text-stone-600 leading-relaxed">
      <p>
        Most AI coding advice is written for people starting a new project or working in a well-structured codebase. If that's you, go read <a href="index.html" class="text-indigo-600 underline">the debate report</a>.
      </p>
      <p>This page is for everyone else. You have:</p>
      <ul class="list-disc list-inside space-y-1 text-stone-700 ml-2">
        <li>Multiple patterns for the same thing (three different ways to handle auth)</li>
        <li>Tests that don't actually test anything useful, or no tests at all</li>
        <li>Documentation that's 60% wrong and you don't know which 60%</li>
        <li>Developers who left and took the "why" with them</li>
        <li>An AI assistant that makes the mess worse because it learns from the mess</li>
      </ul>
      <p class="font-semibold text-stone-800 pt-2">
        The last point is the real problem. In a messy codebase, AI doesn't just fail to help&mdash;it actively amplifies the mess. It finds your three auth patterns, picks the worst one, and replicates it. It reads your bad tests and writes more like them. Garbage in, garbage out, at scale.
      </p>
    </div>
  </div>
</section>

<!-- 15 Minutes to Guardrails -->
<section id="today" class="py-10 px-4 border-t-4 border-red-500 bg-white">
  <div class="max-w-3xl mx-auto">
    <div class="flex items-center gap-3 mb-6">
      <span class="bg-red-600 text-white text-xs font-bold px-3 py-1 rounded-full">DO THIS TODAY</span>
      <h2 class="text-xl font-bold">15 Minutes to Guardrails</h2>
    </div>

    <p class="text-sm text-stone-600 leading-relaxed mb-6">Three files. Copy-paste these into your project. Adapt the specifics to your codebase. Everything below uses the real <a href="https://code.claude.com/docs/en/hooks" class="text-indigo-600 underline">Claude Code hooks API</a>.</p>

    <!-- Step 1: CLAUDE.md -->
    <div class="mb-8">
      <div class="flex items-center gap-2 mb-3">
        <span class="w-7 h-7 rounded-full bg-red-100 text-red-700 flex items-center justify-center text-xs font-bold shrink-0">1</span>
        <p class="font-bold text-sm">Create <code class="bg-stone-100 px-1.5 py-0.5 rounded">CLAUDE.md</code> in your project root</p>
      </div>
      <p class="text-sm text-stone-600 mb-3">Not documentation. Disambiguation. Tell the AI which patterns are current and which are legacy. Name specific files.</p>
      <pre class="bg-stone-800 text-stone-100 rounded-lg p-4 text-xs overflow-x-auto leading-relaxed"><code><span class="text-stone-500"># CLAUDE.md</span>

<span class="text-stone-500">## Build &amp; Test</span>
- Run tests: `bin/rails test`
- Run single test: `bin/rails test test/models/order_test.rb`
- Run linter: `bin/rubocop`

<span class="text-stone-500">## Canonical Examples (IMITATE these patterns)</span>
- Model tests: test/models/order_test.rb
- Service objects: app/services/payment_processor.rb
- API controllers: app/controllers/api/v2/users_controller.rb (NOT v1)
- Authentication: app/services/auth_service.rb

<span class="text-stone-500">## Legacy Code (DO NOT imitate these patterns)</span>
- app/controllers/sessions_controller.rb <span class="text-stone-500"># being replaced by auth_service</span>
- app/models/concerns/authenticatable.rb <span class="text-stone-500"># deprecated</span>
- test/integration/ <span class="text-stone-500"># old test style, use test/models/ pattern instead</span>

<span class="text-stone-500">## Rules</span>
- DO NOT write tests that check column names, file existence, or migration structure.
- DO NOT mock ActiveRecord methods (find, where, save, create).
- DO NOT add logic to controllers. Use service objects.
- Tests must describe behavior ("returns the total with tax"),
  not implementation ("calls the calculate method").
- Always run the full test suite before finishing a task.</code></pre>
      <p class="text-xs text-stone-400 mt-2">Adapt to your stack. The key: point at specific files. "Use THIS, not THAT."</p>
    </div>

    <!-- Step 2: Logging hook -->
    <div class="mb-8">
      <div class="flex items-center gap-2 mb-3">
        <span class="w-7 h-7 rounded-full bg-red-100 text-red-700 flex items-center justify-center text-xs font-bold shrink-0">2</span>
        <p class="font-bold text-sm">Add a logging hook to watch what the AI writes</p>
      </div>
      <p class="text-sm text-stone-600 mb-3">This logs every file the AI creates or edits. Don't block anything yet. Just observe for a week so you can see what goes wrong.</p>

      <p class="text-xs font-semibold text-stone-500 mb-1 uppercase tracking-wide">File: <code>.claude/settings.json</code></p>
      <pre class="bg-stone-800 text-stone-100 rounded-lg p-4 text-xs overflow-x-auto leading-relaxed"><code>{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/log-file-changes.sh"
          }
        ]
      }
    ]
  }
}</code></pre>

      <p class="text-xs font-semibold text-stone-500 mb-1 mt-4 uppercase tracking-wide">File: <code>.claude/hooks/log-file-changes.sh</code></p>
      <pre class="bg-stone-800 text-stone-100 rounded-lg p-4 text-xs overflow-x-auto leading-relaxed"><code>#!/bin/bash
<span class="text-stone-500"># Logs every file the AI creates or modifies.</span>
<span class="text-stone-500"># Review .claude/ai-activity.log weekly to spot recurring patterns.</span>

INPUT=$(cat)
TOOL=$(echo "$INPUT" | jq -r '.tool_name')
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // "unknown"')

echo "$(date +%Y-%m-%d_%H:%M:%S) $TOOL $FILE_PATH" \
  >> "$CLAUDE_PROJECT_DIR/.claude/ai-activity.log"

exit 0</code></pre>

      <p class="text-xs font-semibold text-stone-500 mb-1 mt-4 uppercase tracking-wide">Then make it executable:</p>
      <pre class="bg-stone-800 text-stone-100 rounded-lg p-4 text-xs overflow-x-auto"><code>mkdir -p .claude/hooks
chmod +x .claude/hooks/log-file-changes.sh</code></pre>
    </div>

    <!-- Step 3: Enforcement hook -->
    <div class="mb-8">
      <div class="flex items-center gap-2 mb-3">
        <span class="w-7 h-7 rounded-full bg-red-100 text-red-700 flex items-center justify-center text-xs font-bold shrink-0">3</span>
        <p class="font-bold text-sm">Add your first enforcement hook</p>
      </div>
      <p class="text-sm text-stone-600 mb-3">This blocks the AI from writing test files that contain known slop patterns <strong>before the file is created</strong>. It uses a <code>PreToolUse</code> hook on <code>Write</code> that inspects the file content and returns a <code>deny</code> decision if it matches anti-patterns. Claude sees the denial reason and rewrites the code.</p>

      <p class="text-xs font-semibold text-stone-500 mb-1 uppercase tracking-wide">Add to <code>.claude/settings.json</code> (merge into existing hooks)</p>
      <pre class="bg-stone-800 text-stone-100 rounded-lg p-4 text-xs overflow-x-auto leading-relaxed"><code>{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Write",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/block-slop-tests.sh"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/log-file-changes.sh"
          }
        ]
      }
    ]
  }
}</code></pre>

      <p class="text-xs font-semibold text-stone-500 mb-1 mt-4 uppercase tracking-wide">File: <code>.claude/hooks/block-slop-tests.sh</code></p>
      <pre class="bg-stone-800 text-stone-100 rounded-lg p-4 text-xs overflow-x-auto leading-relaxed"><code>#!/bin/bash
<span class="text-stone-500"># Blocks AI from writing test files that contain known slop patterns.</span>
<span class="text-stone-500"># Only runs on files in test/ or spec/ directories.</span>
<span class="text-stone-500"># Exit 0 = allow. JSON with permissionDecision: "deny" = block.</span>

INPUT=$(cat)
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // ""')
CONTENT=$(echo "$INPUT" | jq -r '.tool_input.content // ""')

<span class="text-stone-500"># Only check test files</span>
if [[ "$FILE_PATH" != *test* ]] && [[ "$FILE_PATH" != *spec* ]]; then
  exit 0
fi

<span class="text-stone-500"># --- Add your banned patterns here ---</span>
BANNED_PATTERNS=(
  "column_names"
  "table_exists?"
  "File\.exist?"
  "\.to have_db_column"
  "expect.*\.to eq.*\.columns"
  "receive(:find)"
  "receive(:where)"
  "receive(:save)"
  "receive(:create)"
  "receive(:update)"
  "receive(:destroy)"
)

for pattern in "${BANNED_PATTERNS[@]}"; do
  if echo "$CONTENT" | grep -qE "$pattern"; then
    jq -n \
      --arg reason "Blocked: test contains '$pattern'. Tests must assert behavior, not implementation details. Check CLAUDE.md for canonical test examples." \
      '{
        hookSpecificOutput: {
          hookEventName: "PreToolUse",
          permissionDecision: "deny",
          permissionDecisionReason: $reason
        }
      }'
    exit 0
  fi
done

<span class="text-stone-500"># No banned patterns found, allow the write</span>
exit 0</code></pre>

      <p class="text-xs font-semibold text-stone-500 mb-1 mt-4 uppercase tracking-wide">Make it executable:</p>
      <pre class="bg-stone-800 text-stone-100 rounded-lg p-4 text-xs overflow-x-auto"><code>chmod +x .claude/hooks/block-slop-tests.sh</code></pre>
    </div>

    <!-- How it works -->
    <div class="bg-stone-100 rounded-lg p-5 mb-4">
      <p class="font-semibold text-stone-800 text-sm mb-2">How this works together</p>
      <ol class="list-decimal list-inside space-y-2 text-stone-600 text-sm">
        <li><strong>CLAUDE.md</strong> loads into Claude's context at session start. It reads "use <code>test/models/order_test.rb</code> as the pattern" and imitates that style.</li>
        <li><strong>block-slop-tests.sh</strong> runs <em>before</em> every file write. If the AI generates a test containing <code>column_names</code> or mocking <code>receive(:find)</code>, the hook denies the write and tells Claude why. Claude sees the reason and regenerates.</li>
        <li><strong>log-file-changes.sh</strong> runs <em>after</em> every file write or edit. You review the log to discover new slop patterns you haven't fenced yet.</li>
      </ol>
    </div>

    <div class="bg-red-50 border border-red-200 rounded-lg p-4">
      <p class="text-red-800 text-sm"><strong>That's it. 15 minutes.</strong> You now have: disambiguation (CLAUDE.md), enforcement (PreToolUse hook), and observability (PostToolUse logging). Everything else in this playbook builds on these three.</p>
    </div>

    <div class="mt-4 bg-stone-50 border border-stone-200 rounded-lg p-4">
      <p class="font-semibold text-stone-700 text-sm mb-1">Prerequisites</p>
      <p class="text-xs text-stone-500"><code>jq</code> must be installed for the hook scripts to parse JSON from stdin. On macOS: <code>brew install jq</code>. On Ubuntu: <code>apt install jq</code>. Claude Code passes hook input as JSON on stdin&mdash;<code>jq</code> extracts the fields your scripts need.</p>
    </div>
  </div>
</section>

<!-- AI-Powered Pattern Assessment -->
<section id="assess" class="py-10 px-4 border-t-4 border-indigo-500 bg-indigo-50/30">
  <div class="max-w-3xl mx-auto">
    <div class="flex items-center gap-3 mb-6">
      <span class="bg-indigo-600 text-white text-xs font-bold px-3 py-1 rounded-full">THE KEY MOVE</span>
      <h2 class="text-xl font-bold">Use AI to Map Your Own Codebase</h2>
    </div>

    <div class="space-y-4 text-sm text-stone-600 leading-relaxed mb-8">
      <p>
        The playbook above tells you to identify canonical vs. legacy patterns. But in a messy codebase, <strong>you might not even know what patterns exist</strong>. There might be three auth approaches and you only know about two. There might be a data access pattern someone introduced six months ago that's actually better than your "official" one.
      </p>
      <p>
        Instead of manually auditing every module, <strong>have the AI do the analysis and present its findings for your judgment</strong>. The AI scans, surfaces competing patterns, shows you real code from your repo, and you decide what's canonical and what's legacy. Then it generates your CLAUDE.md and hook rules from your selections.
      </p>
      <p class="font-semibold text-stone-800">
        This is a real Claude Code skill. Copy the file below into your project, run <code class="bg-white px-1.5 py-0.5 rounded text-xs">/assess-patterns</code>, and walk through the interactive selection.
      </p>
    </div>

    <!-- The Skill File -->
    <div class="mb-8">
      <p class="text-xs font-semibold text-stone-500 mb-1 uppercase tracking-wide">File: <code>.claude/skills/assess-patterns/SKILL.md</code></p>
      <pre class="bg-stone-800 text-stone-100 rounded-lg p-4 text-xs overflow-x-auto leading-relaxed"><code><span class="text-stone-500">---</span>
<span class="text-indigo-300">name</span>: assess-patterns
<span class="text-indigo-300">description</span>: Analyze codebase for competing patterns and present them for human selection as canonical vs. legacy
<span class="text-indigo-300">disable-model-invocation</span>: true
<span class="text-indigo-300">allowed-tools</span>: Read, Grep, Glob, Bash(git log *, git blame *, wc *)
<span class="text-indigo-300">argument-hint</span>: [optional: specific area like "auth" or "testing" or "all"]
<span class="text-stone-500">---</span>

Analyze this codebase to identify competing patterns. Your goal is to
surface every place where multiple approaches exist for the same concern,
so a human can designate which is canonical and which is legacy.

<span class="text-stone-500">## Step 1: Scan for Pattern Families</span>

Examine the codebase structure and identify pattern families where
MORE THAN ONE distinct approach exists. Common families include:

- <span class="text-amber-300">Authentication/Authorization</span>: Devise? Custom service? Concern-based? Multiple?
- <span class="text-amber-300">Data Access</span>: Direct ActiveRecord? Repository pattern? Service objects? Raw SQL?
- <span class="text-amber-300">Testing</span>: What do tests actually assert? Behavioral? Column-level? Mock strategy?
- <span class="text-amber-300">Error Handling</span>: Rescue blocks? Custom error classes? Error response format?
- <span class="text-amber-300">API Responses</span>: Serializers? Jbuilder? as_json? Manual hash construction?
- <span class="text-amber-300">Validation</span>: Model validations? Form objects? Controller-level checks?
- <span class="text-amber-300">Background Jobs</span>: Sidekiq? GoodJob? Delayed Job? Mixed frameworks?
- <span class="text-amber-300">Service Layer</span>: Service objects? Interactors? Command pattern? None?
- <span class="text-amber-300">Frontend Integration</span>: Turbo? React? jQuery? Mixed?

Scan for whatever actually exists. Don't assume these categories apply.
Focus on $ARGUMENTS if specified, otherwise scan all families.

<span class="text-stone-500">## Step 2: Present Findings for Each Family</span>

For each family where you find 2+ distinct approaches, present:

<span class="text-stone-500">### [Pattern Family Name]</span>

<span class="text-stone-500">**Approach A: [descriptive name]**</span>
- Files: [2-3 representative file paths]
- Last modified: [use git log to check recency]
- Occurrences: [count of files using this approach]
- Example: [3-5 line code snippet showing the actual pattern]

<span class="text-stone-500">**Approach B: [descriptive name]**</span>
- Files: [2-3 representative file paths]
- Last modified: [use git log to check recency]
- Occurrences: [count of files using this approach]
- Example: [3-5 line code snippet showing the actual pattern]

<span class="text-stone-500">**Assessment**</span>: Which appears more modern/maintainable and why.
Note if git history suggests a migration was started but not finished.

Then ASK the user:
"Which approach should be canonical? Which is legacy? Or skip this family?"

<span class="text-stone-500">## Step 3: Generate Artifacts from Selections</span>

After the human selects for all families, generate three outputs:

<span class="text-stone-500">### 1. CLAUDE.md Entries</span>
Generate ready-to-paste sections:
```
<span class="text-stone-500">## Canonical Examples (IMITATE these patterns)</span>
- [pattern description]: [specific file path]

<span class="text-stone-500">## Legacy Code (DO NOT imitate these patterns)</span>
- [file path] # [why it's legacy]
```

<span class="text-stone-500">### 2. Hook Patterns</span>
For any legacy pattern detectable by regex, suggest entries for
the BANNED_PATTERNS array in block-slop-tests.sh.

<span class="text-stone-500">### 3. Decision Log Entries</span>
Generate dated entries for decisions.md documenting each
selection with rationale from the human's choices.

<span class="text-stone-500">## Rules</span>
- Only report families where GENUINE competing approaches exist
- Don't manufacture conflicts. If one consistent approach exists, say so
- Always show real file paths and real code from this repo
- Use git log to determine recency, don't guess
- Present your assessment but DEFER to the human's selection
- If the codebase is large, start with the areas of most inconsistency</code></pre>
      <p class="text-xs font-semibold text-stone-500 mb-1 mt-4 uppercase tracking-wide">Create the skill:</p>
      <pre class="bg-stone-800 text-stone-100 rounded-lg p-4 text-xs overflow-x-auto"><code>mkdir -p .claude/skills/assess-patterns
<span class="text-stone-500"># paste the content above into .claude/skills/assess-patterns/SKILL.md</span></code></pre>
    </div>

    <!-- How it works -->
    <div class="mb-8">
      <h3 class="font-bold text-sm mb-4">What the workflow looks like</h3>

      <div class="space-y-3">
        <div class="flex items-start gap-3 bg-white border border-stone-200 rounded-lg p-4">
          <span class="w-6 h-6 rounded-full bg-indigo-100 text-indigo-700 flex items-center justify-center text-xs font-bold shrink-0 mt-0.5">1</span>
          <div>
            <p class="font-semibold text-stone-800 text-sm">You run <code class="bg-stone-100 px-1 py-0.5 rounded text-xs">/assess-patterns</code></p>
            <p class="text-xs text-stone-500 mt-1">Or scope it: <code class="bg-stone-100 px-1 py-0.5 rounded">/assess-patterns auth</code> to focus on authentication only</p>
          </div>
        </div>

        <div class="flex items-start gap-3 bg-white border border-stone-200 rounded-lg p-4">
          <span class="w-6 h-6 rounded-full bg-indigo-100 text-indigo-700 flex items-center justify-center text-xs font-bold shrink-0 mt-0.5">2</span>
          <div>
            <p class="font-semibold text-stone-800 text-sm">Claude scans your codebase and presents competing patterns</p>
            <p class="text-xs text-stone-500 mt-1">For each pattern family, it shows real file paths, code snippets, git recency, and occurrence counts. Example output:</p>
            <pre class="bg-stone-100 rounded p-3 text-xs overflow-x-auto leading-relaxed mt-2"><code><span class="text-stone-500">## Authentication</span>

<span class="text-stone-800 font-semibold">Approach A: Devise + custom controller overrides</span>
Files: app/controllers/users/sessions_controller.rb,
       app/controllers/users/registrations_controller.rb
Last modified: 8 months ago
Occurrences: 4 controllers
Example:
  class Users::SessionsController &lt; Devise::SessionsController
    def create
      super do |resource|
        track_login(resource)
      end
    end
  end

<span class="text-stone-800 font-semibold">Approach B: AuthService with JWT</span>
Files: app/services/auth_service.rb,
       app/controllers/api/v2/auth_controller.rb
Last modified: 2 weeks ago
Occurrences: 2 files (service + controller)
Example:
  class AuthService
    def authenticate(email, password)
      user = User.authenticate_by(email:, password:)
      { token: generate_jwt(user), user: } if user
    end
  end

<span class="text-stone-800 font-semibold">Assessment:</span> Approach B is newer, cleaner separation of
concerns. Approach A has Devise coupling that makes testing
harder. Git history shows Approach B was introduced in PR #142
but migration is incomplete &mdash; API uses B, web still uses A.

<span class="text-indigo-600 font-semibold">Which should be canonical? Which is legacy?</span></code></pre>
          </div>
        </div>

        <div class="flex items-start gap-3 bg-white border border-stone-200 rounded-lg p-4">
          <span class="w-6 h-6 rounded-full bg-indigo-100 text-indigo-700 flex items-center justify-center text-xs font-bold shrink-0 mt-0.5">3</span>
          <div>
            <p class="font-semibold text-stone-800 text-sm">You select: "B is canonical, A is legacy"</p>
            <p class="text-xs text-stone-500 mt-1">Repeat for each pattern family Claude surfaces. Skip any that aren't relevant.</p>
          </div>
        </div>

        <div class="flex items-start gap-3 bg-white border border-stone-200 rounded-lg p-4">
          <span class="w-6 h-6 rounded-full bg-indigo-100 text-indigo-700 flex items-center justify-center text-xs font-bold shrink-0 mt-0.5">4</span>
          <div>
            <p class="font-semibold text-stone-800 text-sm">Claude generates your CLAUDE.md, hook rules, and decision log</p>
            <p class="text-xs text-stone-500 mt-1">Ready to paste. All three artifacts come from your selections, grounded in real code from your repo.</p>
            <pre class="bg-stone-100 rounded p-3 text-xs overflow-x-auto leading-relaxed mt-2"><code><span class="text-stone-500">## Generated CLAUDE.md entries:</span>

<span class="text-stone-500">## Canonical Examples (IMITATE these patterns)</span>
- Authentication: app/services/auth_service.rb
- API auth controller: app/controllers/api/v2/auth_controller.rb

<span class="text-stone-500">## Legacy Code (DO NOT imitate these patterns)</span>
- app/controllers/users/sessions_controller.rb <span class="text-stone-500"># Devise overrides, being replaced by AuthService</span>
- app/controllers/users/registrations_controller.rb <span class="text-stone-500"># same Devise pattern</span>

<span class="text-stone-500">## Generated decisions.md entry:</span>

<span class="text-stone-500">## 2026-02-08: Authentication pattern</span>
Decision: Use AuthService (app/services/auth_service.rb), not Devise controller overrides.
Reason: Cleaner separation, testable without Devise coupling.
Migration started in PR #142, API endpoints already converted.
Remaining: web login/registration controllers.

<span class="text-stone-500">## Generated BANNED_PATTERNS entry:</span>

"Devise::SessionsController"
"Devise::RegistrationsController"</code></pre>
          </div>
        </div>
      </div>
    </div>

    <!-- Why this works -->
    <div class="bg-indigo-50 border border-indigo-200 rounded-lg p-5 mb-6">
      <p class="font-semibold text-indigo-900 text-sm mb-2">Why this is better than manual auditing</p>
      <ul class="list-disc list-inside space-y-1 text-indigo-800 text-sm">
        <li><strong>The AI finds patterns you didn't know about.</strong> It scans every file. You scan the ones you remember.</li>
        <li><strong>Git recency replaces tribal knowledge.</strong> Instead of asking "which auth pattern is current?", the tool checks commit dates.</li>
        <li><strong>The human stays in control.</strong> The AI surfaces and assesses. You decide. Your judgment, AI's legwork.</li>
        <li><strong>Artifacts are immediately actionable.</strong> The output is CLAUDE.md text, hook rules, and decision log entries. Not a report you have to act on later.</li>
      </ul>
    </div>

    <!-- Running it incrementally -->
    <div class="bg-white border border-stone-200 rounded-lg p-5 mb-6">
      <p class="font-semibold text-stone-800 text-sm mb-2">Run it incrementally, not all at once</p>
      <div class="space-y-2 text-sm text-stone-600">
        <p>Don't try to assess your entire codebase in one session. Focus on one area at a time:</p>
        <pre class="bg-stone-100 rounded p-3 text-xs overflow-x-auto leading-relaxed"><code><span class="text-stone-500"># Week 1: Focus on the area that burns you most</span>
/assess-patterns auth

<span class="text-stone-500"># Week 2: Test patterns (where AI slop is worst)</span>
/assess-patterns testing

<span class="text-stone-500"># Week 3: Data access and service layer</span>
/assess-patterns data-access

<span class="text-stone-500"># Week 4: Everything else</span>
/assess-patterns all</code></pre>
        <p>Each run adds entries to your CLAUDE.md and decision log. Your guardrails accumulate session by session.</p>
      </div>
    </div>

    <!-- Re-run over time -->
    <div class="bg-white border border-stone-200 rounded-lg p-5">
      <p class="font-semibold text-stone-800 text-sm mb-2">Re-assess as the codebase evolves</p>
      <div class="space-y-2 text-sm text-stone-600">
        <p>Run <code class="bg-stone-100 px-1 py-0.5 rounded text-xs">/assess-patterns</code> again in 3 months. As you clean up legacy code and introduce new patterns, the assessment changes. Patterns that were "2 competing approaches" become "1 canonical approach." New inconsistencies surface where developers went off-path. Your CLAUDE.md evolves with your codebase because the tool reads what's actually there, not what was there 6 months ago.</p>
      </div>
    </div>
  </div>
</section>

<!-- RAG Is Dead -->
<section id="rag" class="py-10 px-4 border-t border-stone-200">
  <div class="max-w-3xl mx-auto">
    <h2 class="text-xl font-bold mb-2">Is RAG Dead?</h2>
    <p class="text-stone-500 text-sm mb-6">The short answer, the long answer, and what it means for you.</p>

    <div class="space-y-4 text-sm text-stone-600 leading-relaxed">
      <div class="bg-stone-800 text-white rounded-lg p-6">
        <p class="font-bold text-base mb-3">The short answer: for your use case, probably yes.</p>
        <p class="text-stone-300">If you're using Claude Code (or similar AI coding agents) against a single repository, traditional RAG&mdash;embedding your code into vectors and retrieving by similarity&mdash;is overhead you don't need. Claude Code already reads your files directly. It greps, globs, and navigates your codebase with filesystem tools. Adding a vector database on top of that is adding a slower, less accurate middleman.</p>
      </div>

      <p class="font-semibold text-stone-800 pt-2">Why the debate shifted</p>

      <div class="space-y-3 mt-2">
        <div class="border-l-3 border-red-300 pl-4">
          <p class="font-semibold text-stone-800">1. Context windows got huge.</p>
          <p>Claude's context window handles entire modules. You don't need to chunk and embed your code when the model can just read the files. Cache-augmented generation (stuffing relevant files directly into context) <a href="https://ucstrategies.com/news/standard-rag-is-dead-why-ai-architecture-split-in-2026/" class="text-indigo-600 underline">benchmarks at 40x faster</a> than traditional retrieve-then-generate.</p>
        </div>

        <div class="border-l-3 border-red-300 pl-4">
          <p class="font-semibold text-stone-800">2. File-first agents work better for code.</p>
          <p>Claude Code doesn't use RAG. It <a href="https://milvus.io/blog/why-im-against-claude-codes-grep-only-retrieval-it-just-burns-too-many-tokens.md" class="text-indigo-600 underline">reads files directly</a> via grep, glob, and file reads. It sees your actual code, not a lossy vector approximation. For a messy codebase, this matters: you need precision, not similarity.</p>
        </div>

        <div class="border-l-3 border-red-300 pl-4">
          <p class="font-semibold text-stone-800">3. In a messy codebase, similarity is the enemy.</p>
          <p>Your three broken auth patterns are all "similar" to a query about authentication. RAG retrieves all three. It can't tell you which one is current, which is deprecated, and which was a failed experiment. <strong>In a messy codebase, similar code is often the wrong code.</strong> You need CLAUDE.md to say "use this file, not that file"&mdash;that's disambiguation, not retrieval.</p>
        </div>
      </div>

      <div class="bg-amber-50 border border-amber-200 rounded-lg p-5 mt-4">
        <p class="font-semibold text-amber-900 mb-2">When RAG still makes sense</p>
        <p class="text-amber-800 text-sm">RAG isn't dead everywhere. If you have a massive documentation corpus (hundreds of design docs, ADRs, runbooks) that won't fit in context, <a href="https://vstorm.co/rag/why-rag-is-not-dead-a-case-for-context-engineering-over-massive-context-windows/" class="text-indigo-600 underline">semantic search still provides value</a>. But for code-against-code work in a single repo? Skip it. Use direct file access and let your AI agent read files natively.</p>
      </div>
    </div>
  </div>
</section>

<!-- The Playbook -->
<section id="playbook" class="py-10 px-4 border-t border-stone-200 bg-white">
  <div class="max-w-3xl mx-auto">
    <h2 class="text-xl font-bold mb-2">The Playbook</h2>
    <p class="text-stone-500 text-sm mb-8">After the 15-minute setup above, follow these phases. Each builds on the last.</p>

    <!-- Phase 1 -->
    <div class="mb-10">
      <div class="flex items-center gap-3 mb-4">
        <span class="w-10 h-10 rounded-full bg-red-100 text-red-700 flex items-center justify-center text-sm font-bold shrink-0">1</span>
        <div>
          <h3 class="font-bold text-base">Observe and Enforce</h3>
          <p class="text-xs text-stone-500">Week 1-2 &middot; After the 15-minute setup</p>
        </div>
      </div>

      <div class="space-y-3 text-sm text-stone-600 leading-relaxed">
        <p>Use Claude Code for real work with your guardrails in place. At the end of each day, check <code>.claude/ai-activity.log</code>. You're looking for:</p>

        <ul class="list-disc list-inside space-y-1 ml-2">
          <li>Files the AI touches repeatedly (these are the hot zones)</li>
          <li>Patterns the block hook catches (these confirm your CLAUDE.md rules are needed)</li>
          <li>Patterns that slip through (new entries for your <code>BANNED_PATTERNS</code> array)</li>
          <li>Legacy files the AI gravitates toward (add these to CLAUDE.md's legacy section)</li>
        </ul>

        <div class="bg-stone-100 rounded-lg p-5 mt-3">
          <p class="font-semibold text-stone-800 mb-2">Growing your enforcement</p>
          <p>Each time you spot a new slop pattern, add it to <code>BANNED_PATTERNS</code> in <code>block-slop-tests.sh</code>. Each time the AI imitates legacy code, add the file to the legacy section in CLAUDE.md. This is <strong>failure-driven growth</strong>: you only add rules for things that actually went wrong.</p>
        </div>

        <div class="bg-stone-100 rounded-lg p-5 mt-3">
          <p class="font-semibold text-stone-800 mb-2">Add more hooks as patterns emerge</p>
          <p>The test blocker is your first hook. As you observe, you'll want others. Here are real hooks for common messy-codebase problems:</p>

          <p class="text-xs font-semibold text-stone-500 mb-1 mt-3 uppercase tracking-wide">Block writes to protected files (<code>.claude/hooks/protect-files.sh</code>)</p>
          <pre class="bg-stone-200 rounded p-3 text-xs overflow-x-auto leading-relaxed"><code>#!/bin/bash
INPUT=$(cat)
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // ""')

PROTECTED_FILES=(
  "config/initializers/monkey_patches.rb"
  "db/seeds.rb"
  "app/models/user.rb"
)

for protected in "${PROTECTED_FILES[@]}"; do
  if [[ "$FILE_PATH" == *"$protected"* ]]; then
    jq -n --arg reason \
      "Blocked: $protected is a protected file. It has hidden dependencies and should only be modified with explicit human approval. Ask the user first." \
      '{ hookSpecificOutput: { hookEventName: "PreToolUse", permissionDecision: "ask", permissionDecisionReason: $reason } }'
    exit 0
  fi
done

exit 0</code></pre>
          <p class="text-xs text-stone-400 mt-1">Uses <code>permissionDecision: "ask"</code> instead of <code>"deny"</code>&mdash;this prompts you to confirm rather than silently blocking. Good for files that <em>sometimes</em> need changes.</p>

          <p class="text-xs font-semibold text-stone-500 mb-1 mt-4 uppercase tracking-wide">Auto-run tests after every edit (<code>.claude/hooks/run-tests-after-edit.sh</code>)</p>
          <pre class="bg-stone-200 rounded p-3 text-xs overflow-x-auto leading-relaxed"><code>#!/bin/bash
INPUT=$(cat)
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // ""')

# Only run tests when source files change (not configs, docs, etc.)
if [[ "$FILE_PATH" == *app/* ]] || [[ "$FILE_PATH" == *test/* ]] || [[ "$FILE_PATH" == *spec/* ]]; then
  RESULT=$(bin/rails test 2>&1)
  EXIT_CODE=$?

  if [ $EXIT_CODE -ne 0 ]; then
    echo "Tests failed after editing $FILE_PATH. Fix before continuing." >&2
    echo "$RESULT" | tail -20 >&2
    exit 2  # exit 2 = blocking error, stderr fed back to Claude
  fi
fi

exit 0</code></pre>
          <p class="text-xs text-stone-400 mt-1">This is a <code>PostToolUse</code> hook on <code>Write|Edit</code>. Exit code 2 feeds stderr back to Claude as an error. Claude sees the test failures and fixes them.</p>

          <p class="text-xs font-semibold text-stone-500 mb-1 mt-4 uppercase tracking-wide">Full <code>.claude/settings.json</code> with all hooks</p>
          <pre class="bg-stone-200 rounded p-3 text-xs overflow-x-auto leading-relaxed"><code>{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Write",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/block-slop-tests.sh"
          }
        ]
      },
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/protect-files.sh"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/log-file-changes.sh"
          },
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/run-tests-after-edit.sh",
            "timeout": 120
          }
        ]
      }
    ]
  }
}</code></pre>
        </div>
      </div>
    </div>

    <!-- Phase 2 -->
    <div class="mb-10">
      <div class="flex items-center gap-3 mb-4">
        <span class="w-10 h-10 rounded-full bg-amber-100 text-amber-700 flex items-center justify-center text-sm font-bold shrink-0">2</span>
        <div>
          <h3 class="font-bold text-base">Map the Mess</h3>
          <p class="text-xs text-stone-500">Week 2-3</p>
        </div>
      </div>

      <div class="space-y-3 text-sm text-stone-600 leading-relaxed">
        <p>Now that the AI isn't making things worse, identify the <strong>decision points</strong>&mdash;places where the mess has multiple paths and someone needs to know which one is current.</p>

        <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-3">
          <p class="text-amber-800 text-sm"><strong>Don't do this manually.</strong> Use the <a href="#assess" class="text-indigo-600 underline font-semibold">/assess-patterns skill</a> above to have Claude scan your codebase, surface competing patterns, and present them for your selection. It generates CLAUDE.md entries, hook rules, and decision log entries from your choices.</p>
        </div>

        <div class="bg-stone-100 rounded-lg p-5">
          <ol class="list-decimal list-inside space-y-3">
            <li>
              <strong>Run <code>/assess-patterns</code> on one area at a time.</strong> Start with auth, then testing, then data access. Each run adds to your CLAUDE.md and decision log. Don't try to map the whole codebase at once.
            </li>
            <li>
              <strong>Review and adjust the generated artifacts.</strong> The AI's assessment is a starting point. You know things it doesn't&mdash;upcoming migrations, business constraints, team preferences. Edit the generated CLAUDE.md entries before committing them.
            </li>
            <li>
              <strong>Start a decision log.</strong> The skill generates entries, but keep adding manually too. Every time you or the AI makes a choice between competing patterns, write it down with a date, the decision, and why.
              <pre class="bg-stone-200 rounded p-3 mt-2 text-xs overflow-x-auto leading-relaxed"><code># decisions.md

## 2026-02-07: Auth pattern
Decision: Use AuthService (app/services/auth_service.rb),
not the Authenticatable concern.
Reason: The concern mixes session and token auth.
AuthService separates them. See PR #142.
Source: /assess-patterns auth

## 2026-02-08: Test style
Decision: Minitest with behavioral descriptions.
Reason: Column-level assertions don't catch real bugs.
Canonical example: test/models/order_test.rb
Source: /assess-patterns testing</code></pre>
            </li>
            <li>
              <strong>Add no-fly zones to CLAUDE.md</strong> for files that look simple but have hidden dependencies. The assessment skill will flag files with heavy coupling, but you'll know about the truly dangerous ones that require human judgment.
            </li>
          </ol>
        </div>

        <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mt-2">
          <p class="text-amber-800 text-sm"><strong>Why this matters:</strong> The AI can read your entire codebase. The problem isn't access&mdash;it's signal-to-noise. When three patterns exist for the same thing, the AI needs a human to say "this one." The assessment skill surfaces the conflicts. You make the calls. CLAUDE.md records them. <strong>AI legwork, human judgment.</strong></p>
        </div>
      </div>
    </div>

    <!-- Phase 3 -->
    <div class="mb-10">
      <div class="flex items-center gap-3 mb-4">
        <span class="w-10 h-10 rounded-full bg-emerald-100 text-emerald-700 flex items-center justify-center text-sm font-bold shrink-0">3</span>
        <div>
          <h3 class="font-bold text-base">Clean As You Go</h3>
          <p class="text-xs text-stone-500">Month 2+ &middot; Ongoing</p>
        </div>
      </div>

      <div class="space-y-3 text-sm text-stone-600 leading-relaxed">
        <p>Use the AI to incrementally clean the mess. Not a big-bang refactor. Small, targeted cleanups tied to feature work.</p>

        <div class="bg-stone-100 rounded-lg p-5">
          <ol class="list-decimal list-inside space-y-3">
            <li><strong>Every feature task, add one cleanup task.</strong> Working on the orders module? Migrate one legacy pattern to canonical while you're there. Update CLAUDE.md. The AI learns from the migration for next time.</li>
            <li><strong>Update the decision log with each cleanup.</strong> "Migrated OrdersController from v1 auth to AuthService. Old code removed. PR #167."</li>
            <li><strong>Retire hooks as the codebase improves.</strong> Once all legacy auth code is migrated, the hook blocking it becomes unnecessary. Remove it. Hooks reflect current risks, not historical ones.</li>
            <li><strong>Let the canonical list grow.</strong> Each cleanup establishes a new canonical example. CLAUDE.md becomes your actual style guide&mdash;pointers to real code, not prose about what to do.</li>
          </ol>
        </div>

        <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4 mt-2">
          <p class="text-emerald-800 text-sm"><strong>The principle:</strong> You're establishing beachheads of quality and expanding them. Each cleaned zone makes the AI better in that zone because it now has a correct example to learn from.</p>
        </div>
      </div>
    </div>

    <!-- Phase 4 -->
    <div class="mb-10">
      <div class="flex items-center gap-3 mb-4">
        <span class="w-10 h-10 rounded-full bg-indigo-100 text-indigo-700 flex items-center justify-center text-sm font-bold shrink-0">4</span>
        <div>
          <h3 class="font-bold text-base">Scale What Worked</h3>
          <p class="text-xs text-stone-500">Month 6+ &middot; When pain justifies it</p>
        </div>
      </div>

      <div class="space-y-3 text-sm text-stone-600 leading-relaxed">
        <p>By now you have a CLAUDE.md that disambiguates, hooks that enforce, a decision log that captures rationale, and canonical examples for each pattern. Add sophistication only where it earns its keep:</p>

        <div class="bg-stone-100 rounded-lg p-5">
          <ul class="list-disc list-inside space-y-2">
            <li><strong>MCP servers for structural queries</strong> when "what depends on this?" becomes a recurring question.</li>
            <li><strong>Skills files</strong> when you catch yourself giving the AI the same multi-line instruction every time.</li>
            <li><strong>Subagents</strong> for scoped tasks: separate agents for tests, implementation, and review, each with different hooks.</li>
            <li><strong>Prompt-based hooks</strong> for checks too nuanced for regex. Claude Code supports <code>"type": "prompt"</code> hooks that use an LLM to evaluate whether to allow or block:
              <pre class="bg-stone-200 rounded p-3 mt-2 text-xs overflow-x-auto leading-relaxed"><code>{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "Review the conversation. Did Claude run the test suite and confirm all tests pass before stopping? If not, respond with {\"ok\": false, \"reason\": \"Run the test suite before finishing.\"}. If yes, respond with {\"ok\": true}. Context: $ARGUMENTS"
          }
        ]
      }
    ]
  }
}</code></pre>
              <p class="text-xs text-stone-400 mt-1">This runs a lightweight LLM check every time Claude tries to stop. If it didn't run tests, it's told to go back and do it.</p>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- The Anti-Patterns -->
<section id="anti-patterns" class="py-10 px-4 border-t border-stone-200">
  <div class="max-w-3xl mx-auto">
    <h2 class="text-xl font-bold mb-6">What Not To Do</h2>

    <div class="space-y-4">
      <div class="flex items-start gap-3 p-4 border border-red-200 rounded-lg bg-red-50">
        <span class="text-red-600 font-bold text-lg shrink-0 mt-0.5">&times;</span>
        <div>
          <p class="font-semibold text-sm text-red-900">Don't write comprehensive documentation first.</p>
          <p class="text-sm text-red-800">In a messy codebase, any documentation you write today will be wrong about parts you haven't discovered yet. Document as you discover, not upfront.</p>
        </div>
      </div>

      <div class="flex items-start gap-3 p-4 border border-red-200 rounded-lg bg-red-50">
        <span class="text-red-600 font-bold text-lg shrink-0 mt-0.5">&times;</span>
        <div>
          <p class="font-semibold text-sm text-red-900">Don't embed your messy code into vectors.</p>
          <p class="text-sm text-red-800">RAG over a messy codebase retrieves messy examples. You're training the AI on your worst code. Use direct file access and point it at specific canonical files instead.</p>
        </div>
      </div>

      <div class="flex items-start gap-3 p-4 border border-red-200 rounded-lg bg-red-50">
        <span class="text-red-600 font-bold text-lg shrink-0 mt-0.5">&times;</span>
        <div>
          <p class="font-semibold text-sm text-red-900">Don't build a knowledge graph of your existing codebase.</p>
          <p class="text-sm text-red-800">A graph of a mess is just a more expensive mess. Fix the patterns first, then graph what's worth preserving.</p>
        </div>
      </div>

      <div class="flex items-start gap-3 p-4 border border-red-200 rounded-lg bg-red-50">
        <span class="text-red-600 font-bold text-lg shrink-0 mt-0.5">&times;</span>
        <div>
          <p class="font-semibold text-sm text-red-900">Don't give the AI unrestricted codebase access.</p>
          <p class="text-sm text-red-800">It will find and imitate the worst code. Use CLAUDE.md to point at canonical examples. Use hooks to block known bad patterns. Scope access with MCP servers when modules are large enough.</p>
        </div>
      </div>

      <div class="flex items-start gap-3 p-4 border border-red-200 rounded-lg bg-red-50">
        <span class="text-red-600 font-bold text-lg shrink-0 mt-0.5">&times;</span>
        <div>
          <p class="font-semibold text-sm text-red-900">Don't big-bang refactor with AI.</p>
          <p class="text-sm text-red-800"><a href="https://www.technologyreview.com/2025/12/15/1128352/rise-of-ai-coding-developers-2026/" class="underline">AI lacks the context</a> to understand ripple effects across a legacy system. Clean incrementally. One module per feature. Verify after each change.</p>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- Quick Reference -->
<section id="reference" class="py-10 px-4 border-t border-stone-200 bg-white">
  <div class="max-w-3xl mx-auto">
    <h2 class="text-xl font-bold mb-6">Quick Reference</h2>

    <div class="overflow-x-auto">
      <table class="w-full text-xs border-collapse">
        <thead>
          <tr class="bg-stone-800 text-white">
            <th class="px-4 py-3 text-left font-semibold rounded-tl-lg">Tool</th>
            <th class="px-4 py-3 text-left font-semibold">Messy Codebase Use</th>
            <th class="px-4 py-3 text-left font-semibold rounded-tr-lg">When</th>
          </tr>
        </thead>
        <tbody class="divide-y divide-stone-200">
          <tr class="bg-white">
            <td class="px-4 py-3 font-semibold text-stone-800">CLAUDE.md</td>
            <td class="px-4 py-3"><strong>Disambiguation.</strong> "Use THIS file as the pattern, not THAT one." Points to specific canonical examples and marks legacy code explicitly.</td>
            <td class="px-4 py-3">Day 1</td>
          </tr>
          <tr class="bg-stone-50">
            <td class="px-4 py-3 font-semibold text-stone-800">/assess-patterns</td>
            <td class="px-4 py-3"><strong>AI-powered codebase audit.</strong> Scans for competing patterns, surfaces them with git recency and code examples, lets you designate canonical vs. legacy, generates CLAUDE.md and hook rules.</td>
            <td class="px-4 py-3">Day 1</td>
          </tr>
          <tr class="bg-white">
            <td class="px-4 py-3 font-semibold text-stone-800">PreToolUse Hooks</td>
            <td class="px-4 py-3"><strong>Block slop before it lands.</strong> Inspect file content before writes. Deny patterns that match known anti-patterns. Protect sensitive files with confirmation prompts.</td>
            <td class="px-4 py-3">Day 1</td>
          </tr>
          <tr class="bg-white">
            <td class="px-4 py-3 font-semibold text-stone-800">PostToolUse Hooks</td>
            <td class="px-4 py-3"><strong>Observe and verify.</strong> Log all AI file operations. Auto-run tests after edits. Feed test failures back to Claude via exit code 2.</td>
            <td class="px-4 py-3">Day 1</td>
          </tr>
          <tr class="bg-stone-50">
            <td class="px-4 py-3 font-semibold text-stone-800">decisions.md</td>
            <td class="px-4 py-3"><strong>Institutional memory.</strong> Why you chose pattern A over B. Dated, attributed, linked to PRs. Survives developer turnover.</td>
            <td class="px-4 py-3">Week 2</td>
          </tr>
          <tr class="bg-white">
            <td class="px-4 py-3 font-semibold text-stone-800">Stop Hooks</td>
            <td class="px-4 py-3"><strong>Quality gates.</strong> Prevent Claude from finishing until tests pass or required checks complete. Use <code>"type": "prompt"</code> for nuanced checks.</td>
            <td class="px-4 py-3">Month 1+</td>
          </tr>
          <tr class="bg-stone-50">
            <td class="px-4 py-3 font-semibold text-stone-800">MCP Servers</td>
            <td class="px-4 py-3"><strong>Scoped access.</strong> Give the AI structured views of specific modules via pluggable context sources.</td>
            <td class="px-4 py-3">Month 2+</td>
          </tr>
          <tr class="bg-white">
            <td class="px-4 py-3 font-semibold text-stone-800">Skills</td>
            <td class="px-4 py-3"><strong>Reusable workflows.</strong> Same prompt template every time for common tasks (writing tests, creating PRs, etc.)</td>
            <td class="px-4 py-3">Month 2+</td>
          </tr>
          <tr class="bg-stone-50">
            <td class="px-4 py-3 font-semibold text-stone-800">RAG / Embeddings</td>
            <td class="px-4 py-3"><strong>Decision log search only.</strong> Not over code. Over your accumulated human decisions, when the log is too big to grep.</td>
            <td class="px-4 py-3">Month 6+ (if ever)</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</section>

<!-- The Bottom Line -->
<section class="py-10 px-4 border-t border-stone-200">
  <div class="max-w-3xl mx-auto">
    <h2 class="text-xl font-bold mb-6">The Bottom Line</h2>

    <div class="space-y-4 text-sm text-stone-600 leading-relaxed">
      <p>
        In a messy codebase, the AI context problem isn't "how do I give the AI enough information?" It's <strong>"how do I prevent the AI from drowning in bad information?"</strong>
      </p>
      <p>The strategy is three moves:</p>

      <div class="grid md:grid-cols-3 gap-4 mt-4">
        <div class="bg-red-50 border border-red-200 rounded-lg p-4 text-center">
          <p class="font-bold text-red-800 text-2xl mb-1">Fence</p>
          <p class="text-red-700 text-xs">Hooks block bad output.<br>Protected files require confirmation.<br>Enforcement grows from real failures.</p>
        </div>
        <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 text-center">
          <p class="font-bold text-amber-800 text-2xl mb-1">Point</p>
          <p class="text-amber-700 text-xs">CLAUDE.md names canonical files.<br>Explicit "use this, not that."<br>Disambiguation over documentation.</p>
        </div>
        <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4 text-center">
          <p class="font-bold text-emerald-800 text-2xl mb-1">Expand</p>
          <p class="text-emerald-700 text-xs">Clean one zone per feature.<br>Each cleanup teaches the AI.<br>Quality beachheads grow outward.</p>
        </div>
      </div>

      <p class="pt-4">
        Every tool in the <a href="index.html" class="text-indigo-600 underline">Context Wars debate</a> has a role. But in a messy codebase, the order matters more than the tools. Fence first. Point second. Expand third. Skip nothing.
      </p>
    </div>
  </div>
</section>

<!-- Footer -->
<footer class="py-10 px-4 border-t border-stone-200 bg-stone-100">
  <div class="max-w-3xl mx-auto text-center">
    <p class="text-stone-500 text-xs mb-2">
      Part of <a href="index.html" class="underline">The Context Wars</a> &middot; February 2026
    </p>
    <p class="text-stone-400 text-xs">
      Sources:
      <a href="https://code.claude.com/docs/en/hooks" class="underline">Claude Code Hooks Docs</a> &middot;
      <a href="https://ucstrategies.com/news/standard-rag-is-dead-why-ai-architecture-split-in-2026/" class="underline">UCStrategies</a> &middot;
      <a href="https://vstorm.co/rag/why-rag-is-not-dead-a-case-for-context-engineering-over-massive-context-windows/" class="underline">Vstorm</a> &middot;
      <a href="https://addyosmani.com/blog/ai-coding-workflow/" class="underline">Addy Osmani</a> &middot;
      <a href="https://milvus.io/blog/why-im-against-claude-codes-grep-only-retrieval-it-just-burns-too-many-tokens.md" class="underline">Milvus</a> &middot;
      <a href="https://www.technologyreview.com/2025/12/15/1128352/rise-of-ai-coding-developers-2026/" class="underline">MIT Tech Review</a>
    </p>
  </div>
</footer>

</body>
</html>
